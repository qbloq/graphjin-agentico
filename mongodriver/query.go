// Package mongodriver provides a database/sql compatible driver for MongoDB.
// It accepts JSON query DSL generated by GraphJin's MongoDB dialect and
// translates it to MongoDB aggregation pipelines.
package mongodriver

import (
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
)

// QueryDSL represents the JSON query structure generated by the MongoDB dialect.
// This is the "SQL" that GraphJin generates for MongoDB.
type QueryDSL struct {
	Operation         string           `json:"operation"`
	Collection        string           `json:"collection,omitempty"`
	FieldName         string           `json:"field_name,omitempty"`     // GraphQL field name to wrap result in
	Singular          bool             `json:"singular,omitempty"`       // If true, return single object instead of array
	Typename          string           `json:"typename,omitempty"`       // If set, add __typename field with this value to each result
	QueryTypename     string           `json:"query_typename,omitempty"` // If set, add root __typename field with this value
	Pipeline          []map[string]any `json:"pipeline,omitempty"`
	Document          map[string]any   `json:"document,omitempty"`
	Documents         []map[string]any `json:"documents,omitempty"`       // For bulk inserts (insertMany)
	RawDocument       string           `json:"raw_document,omitempty"`    // Raw document placeholder (e.g., "$1")
	ConnectColumn     string           `json:"connect_column,omitempty"`  // Array column to populate from connect
	ConnectPath       string           `json:"connect_path,omitempty"`    // Path to connect IDs in document (e.g., "$2")
	FKConnect         *FKConnect       `json:"fk_connect,omitempty"`      // FK column to populate from connect (single value)
	FKConnects        []FKConnect      `json:"fk_connects,omitempty"`     // Multiple FK columns to populate from connects
	FKValues          map[string]any   `json:"fk_values,omitempty"`       // Direct FK values to set on root document
	ReturnPipeline    []map[string]any `json:"return_pipeline,omitempty"` // Pipeline to run after insert to fetch return data
	Filter            map[string]any   `json:"filter,omitempty"`
	Update            map[string]any   `json:"update,omitempty"`
	Options           map[string]any   `json:"options,omitempty"`
	Presets           map[string]any   `json:"presets,omitempty"` // Preset values to merge with document
	Params            []string         `json:"params,omitempty"`
	Queries           []*QueryDSL      `json:"queries,omitempty"`             // For multi_aggregate operations
	Inserts           []NestedInsert   `json:"inserts,omitempty"`             // For nested_insert operations
	Updates           []NestedUpdate   `json:"updates,omitempty"`             // For nested_update operations
	RootCollection    string           `json:"root_collection,omitempty"`     // Root collection for nested_insert/nested_update
	RootMutateID      int              `json:"root_mutate_id,omitempty"`      // ID of root mutation for nested_insert
	AllSameCollection bool             `json:"all_same_collection,omitempty"` // True if all inserts are in same collection (recursive-only)
	Condition         *QueryCondition  `json:"condition,omitempty"`           // Condition for variable-based directives
	CursorInfo        *CursorInfo      `json:"cursor_info,omitempty"`         // Cursor pagination metadata
	CursorParam       string           `json:"cursor_param,omitempty"`        // Parameter placeholder for cursor value (e.g., "$1")
}

// NestedInsert represents a single insert in a nested mutation operation.
type NestedInsert struct {
	Collection string         `json:"collection"`
	ID         int            `json:"id"`
	ParentID   int            `json:"parent_id"`
	RelType    string         `json:"rel_type,omitempty"`     // "one_to_one" or "one_to_many"
	FKCol      string         `json:"fk_col,omitempty"`       // FK column name (e.g., "owner_id")
	FKOnParent bool           `json:"fk_on_parent,omitempty"` // true if FK is on parent table, false if on child
	IsConnect  bool           `json:"is_connect,omitempty"`   // true if this is a connect (UPDATE) rather than insert
	Document   map[string]any `json:"document"`
}

// NestedUpdate represents a single update in a nested mutation operation.
type NestedUpdate struct {
	Collection string         `json:"collection"`
	ID         int            `json:"id"`
	ParentID   int            `json:"parent_id"`
	Type       string         `json:"type"`                   // "update", "connect", "disconnect"
	RelType    string         `json:"rel_type,omitempty"`     // Relationship type
	FKCol      string         `json:"fk_col,omitempty"`       // FK column to update for connect/disconnect
	FKOnParent bool           `json:"fk_on_parent,omitempty"` // true if FK is on parent table
	Filter     map[string]any `json:"filter"`
	Update     map[string]any `json:"update,omitempty"`
}

// FKConnect represents metadata for FK connect operations.
// Used to transform owner.connect.id -> owner_id during document processing.
type FKConnect struct {
	Path   string `json:"path"`   // Field path in document (e.g., "owner")
	Column string `json:"column"` // FK column name (e.g., "owner_id")
}

// QueryCondition represents a condition for variable-based directives.
// Used for @skip(ifVar: $var) and @include(ifVar: $var) on root selections.
type QueryCondition struct {
	// VarParam is the parameter placeholder (e.g., "$1") for the variable value
	VarParam string `json:"var_param"`
	// Op is the operation: "eq" for @include (show if var == true),
	// "ne" for @skip (show if var != true)
	Op string `json:"op"`
}

// CursorInfo contains metadata for cursor-based pagination.
// Used to extract cursor values from query results.
type CursorInfo struct {
	SelID   int            `json:"sel_id"`   // Selection ID for cursor prefix
	Prefix  string         `json:"prefix"`   // Cursor prefix (e.g., "gj-")
	OrderBy []CursorColumn `json:"order_by"` // Order-by columns for cursor value
}

// CursorColumn represents an order-by column for cursor extraction.
type CursorColumn struct {
	Col   string `json:"col"`   // Column name
	Order string `json:"order"` // "asc" or "desc"
}

// Supported operations
const (
	OpAggregate         = "aggregate"
	OpMultiAggregate    = "multi_aggregate"
	OpMultiMutation     = "multi_mutation"
	OpFind              = "find"
	OpFindOne           = "findOne"
	OpInsertOne         = "insertOne"
	OpInsertMany        = "insertMany"
	OpUpdateOne         = "updateOne"
	OpUpdateMany        = "updateMany"
	OpDeleteOne         = "deleteOne"
	OpDeleteMany        = "deleteMany"
	OpNestedInsert      = "nested_insert"
	OpNestedUpdate      = "nested_update"
	OpIntrospectInfo    = "introspect_info"
	OpIntrospectColumns = "introspect_columns"
	OpIntrospectFuncs   = "introspect_functions"
	OpEmpty             = "empty" // For dropped root selections (@add/@remove directives)
	OpNull              = "null"  // For nulled selections (@skip/@include directives)
)

// ParseQuery parses a JSON query DSL string into a QueryDSL struct.
func ParseQuery(query string) (*QueryDSL, error) {
	var q QueryDSL
	if err := json.Unmarshal([]byte(query), &q); err != nil {
		return nil, fmt.Errorf("mongodriver: invalid query DSL: %w", err)
	}
	if q.Operation == "" {
		return nil, fmt.Errorf("mongodriver: missing operation in query DSL")
	}
	return &q, nil
}

// SubstituteParams replaces parameter placeholders ($1, $2, etc.) with actual values.
func (q *QueryDSL) SubstituteParams(args []any) error {
	if len(args) == 0 {
		return nil
	}

	// Build param map
	paramMap := make(map[string]any)
	for i, arg := range args {
		paramMap[fmt.Sprintf("$%d", i+1)] = arg
	}

	// Substitute in pipeline
	for i, stage := range q.Pipeline {
		q.Pipeline[i] = substituteInMap(stage, paramMap)
	}

	// Substitute in filter
	if q.Filter != nil {
		q.Filter = substituteInMap(q.Filter, paramMap)
	}

	// Substitute in document
	if q.Document != nil {
		q.Document = substituteInMap(q.Document, paramMap)
	}

	// Substitute in documents array (for inline bulk inserts)
	if len(q.Documents) > 0 {
		for i, doc := range q.Documents {
			q.Documents[i] = substituteInMap(doc, paramMap)
		}
	}

	// Substitute in update
	if q.Update != nil {
		q.Update = substituteInMap(q.Update, paramMap)
	}

	// Substitute in presets
	if q.Presets != nil {
		q.Presets = substituteInMap(q.Presets, paramMap)
	}

	// Handle RawDocument - parse the parameter value as JSON into Document or Documents
	if q.RawDocument != "" {
		if val, ok := paramMap[q.RawDocument]; ok {
			// The value should be a JSON string that we parse into the Document
			var rawStr string
			switch v := val.(type) {
			case string:
				rawStr = v
			case []byte:
				rawStr = string(v)
			case json.RawMessage:
				rawStr = string(v)
			default:
				return fmt.Errorf("mongodriver: raw_document parameter must be string, []byte, or json.RawMessage, got %T", val)
			}

			// Try to parse as array first (for bulk inserts)
			rawBytes := []byte(rawStr)
			if len(rawBytes) > 0 && rawBytes[0] == '[' {
				var docs []map[string]any
				if err := json.Unmarshal(rawBytes, &docs); err != nil {
					return fmt.Errorf("mongodriver: failed to parse raw_document JSON array: %w", err)
				}
				q.Documents = docs
				// Switch operation from insertOne to insertMany for bulk inserts
				if q.Operation == OpInsertOne {
					q.Operation = OpInsertMany
				}
			} else {
				// Parse as single object
				var doc map[string]any
				if err := json.Unmarshal(rawBytes, &doc); err != nil {
					return fmt.Errorf("mongodriver: failed to parse raw_document JSON: %w", err)
				}
				q.Document = doc
			}
		}
	}

	// Handle ConnectColumn - extract connect IDs from the document
	// The IDs are embedded in the Document under "tablename.connect.id" pattern
	// We need to extract them and add them to the document as the ConnectColumn
	if q.ConnectColumn != "" && q.Document != nil {
		extractConnectIDs(q.Document, q.ConnectColumn)
	}

	// Handle FK connect - transform owner.connect.id -> owner_id
	if q.FKConnect != nil && q.Document != nil {
		transformFKConnect(q.Document, q.FKConnect.Path, q.FKConnect.Column)
	}

	// Handle multiple FK connects - transform each path.connect.id -> column
	for _, fkc := range q.FKConnects {
		if q.Document != nil {
			transformFKConnect(q.Document, fkc.Path, fkc.Column)
		}
	}

	// Substitute in nested queries (for multi_aggregate and multi_mutation)
	for _, subQ := range q.Queries {
		if err := subQ.SubstituteParams(args); err != nil {
			return err
		}
	}

	// Substitute in nested updates (for nested_update)
	for i := range q.Updates {
		if q.Updates[i].Filter != nil {
			q.Updates[i].Filter = substituteInMap(q.Updates[i].Filter, paramMap)
		}
		if q.Updates[i].Update != nil {
			q.Updates[i].Update = substituteInMap(q.Updates[i].Update, paramMap)
		}
	}

	// Evaluate condition for variable-based directives
	// If condition is false, change operation to "null"
	if q.Condition != nil {
		if !q.evaluateCondition(paramMap) {
			q.Operation = OpNull
		}
		// Clear condition after evaluation
		q.Condition = nil
	}

	// Handle cursor-based seek filtering for cursor pagination
	if q.CursorParam != "" && q.CursorInfo != nil && len(q.CursorInfo.OrderBy) > 0 {
		if cursorVal, ok := paramMap[q.CursorParam]; ok && cursorVal != nil {
			cursorStr, isString := cursorVal.(string)
			if isString && cursorStr != "" {
				seekFilter := buildCursorSeekFilter(q.CursorInfo, cursorStr)
				if seekFilter != nil {
					// Prepend the seek filter to the pipeline
					q.Pipeline = append([]map[string]any{seekFilter}, q.Pipeline...)
				}
			}
		}
	}

	return nil
}

// buildCursorSeekFilter builds a $match stage for cursor-based seek pagination.
// Supported cursor inputs:
// - prefixed: gj-hexTs:selID:val1:val2:...
// - normalized: selID:val1:val2:...
// For ORDER BY price DESC, id DESC with cursor values [100.50, 99], the filter is:
// { "$or": [
//
//	{ "price": { "$lt": 100.50 } },
//	{ "$and": [{ "price": 100.50 }, { "_id": { "$lt": 99 } }] }
//
// ] }
func buildCursorSeekFilter(info *CursorInfo, cursorStr string) map[string]any {
	cursorStr = normalizeCursorForSeek(info, cursorStr)
	if cursorStr == "" {
		return nil
	}

	// Parse normalized cursor string: selID:val1:val2:...
	parts := strings.Split(cursorStr, ":")
	if len(parts) < 2 {
		return nil // Invalid cursor format
	}

	// Skip selID (first part), get cursor values
	cursorValues := parts[1:]

	if len(cursorValues) < len(info.OrderBy) {
		return nil // Not enough cursor values
	}

	// Build the seek predicate
	// For n order-by columns, we need:
	// (col1 < val1) OR
	// (col1 = val1 AND col2 < val2) OR
	// (col1 = val1 AND col2 = val2 AND col3 < val3) OR
	// ... etc
	var orConditions []map[string]any

	for i := 0; i < len(info.OrderBy); i++ {
		var andConditions []map[string]any

		// Add equality conditions for all preceding columns
		for j := 0; j < i; j++ {
			colName := info.OrderBy[j].Col
			// Translate "id" to "_id" for MongoDB
			if colName == "id" {
				colName = "_id"
			}
			val := parseCursorValue(cursorValues[j])
			andConditions = append(andConditions, map[string]any{
				colName: val,
			})
		}

		// Add the comparison condition for this column
		colName := info.OrderBy[i].Col
		// Translate "id" to "_id" for MongoDB
		if colName == "id" {
			colName = "_id"
		}
		val := parseCursorValue(cursorValues[i])
		order := info.OrderBy[i].Order

		var cmp string
		if order == "desc" {
			cmp = "$lt" // For DESC order, seek forward means less than
		} else {
			cmp = "$gt" // For ASC order, seek forward means greater than
		}

		andConditions = append(andConditions, map[string]any{
			colName: map[string]any{cmp: val},
		})

		// If we have multiple conditions, wrap in $and; otherwise use single condition
		if len(andConditions) == 1 {
			orConditions = append(orConditions, andConditions[0])
		} else {
			orConditions = append(orConditions, map[string]any{
				"$and": andConditions,
			})
		}
	}

	// Wrap in $or if multiple conditions, otherwise return single condition
	if len(orConditions) == 1 {
		return map[string]any{"$match": orConditions[0]}
	}

	return map[string]any{
		"$match": map[string]any{
			"$or": orConditions,
		},
	}
}

// normalizeCursorForSeek normalizes a cursor to selID:val1:val2 form.
// It accepts both prefixed and already-normalized cursor values.
func normalizeCursorForSeek(info *CursorInfo, cursorStr string) string {
	cursorStr = strings.TrimSpace(cursorStr)
	if cursorStr == "" {
		return ""
	}

	// Strip the exact dialect prefix first when available.
	if info != nil && info.Prefix != "" && strings.HasPrefix(cursorStr, info.Prefix) {
		return strings.TrimPrefix(cursorStr, info.Prefix)
	}

	// Fallback for legacy/security-prefixed cursors: gj-...:<payload>
	// Example: gj-65a8b3c0:12:100.5:99 -> 12:100.5:99
	if strings.HasPrefix(cursorStr, "gj-") {
		if idx := strings.Index(cursorStr, ":"); idx != -1 && idx+1 < len(cursorStr) {
			return cursorStr[idx+1:]
		}
	}

	return cursorStr
}

// parseCursorValue attempts to convert a cursor string value to the appropriate type.
func parseCursorValue(s string) any {
	// Try to parse as integer
	if i, err := strconv.ParseInt(s, 10, 64); err == nil {
		return i
	}
	// Try to parse as float
	if f, err := strconv.ParseFloat(s, 64); err == nil {
		return f
	}
	// Return as string
	return s
}

// evaluateCondition checks if the query condition is satisfied.
// Returns true if the query should be executed, false if it should be nulled.
func (q *QueryDSL) evaluateCondition(paramMap map[string]any) bool {
	if q.Condition == nil {
		return true
	}

	// Get the variable value from params
	val, ok := paramMap[q.Condition.VarParam]
	if !ok {
		// Variable not provided - treat as false
		return q.Condition.Op == "ne" // @skip without var should skip, @include without var should not include
	}

	// Check if value is truthy
	isTruthy := false
	switch v := val.(type) {
	case bool:
		isTruthy = v
	case string:
		isTruthy = v == "true" || v == "1"
	case int, int32, int64:
		isTruthy = v != 0
	case float32, float64:
		isTruthy = v != 0
	default:
		isTruthy = v != nil
	}

	// Apply operation
	switch q.Condition.Op {
	case "eq":
		// @include(ifVar: $var): show if var == true
		return isTruthy
	case "ne":
		// @skip(ifVar: $var): show if var != true (i.e., show when var is false)
		return !isTruthy
	default:
		return true
	}
}

// extractConnectIDs looks for "tablename: {connect: {id: [...]}} patterns in the document
// and extracts the IDs into a flat array column
func extractConnectIDs(doc map[string]any, connectColumn string) {
	// Look for nested objects that have "connect" with "id" array
	for key, val := range doc {
		if nestedObj, ok := val.(map[string]any); ok {
			if connectObj, hasConnect := nestedObj["connect"].(map[string]any); hasConnect {
				if ids, hasIDs := connectObj["id"]; hasIDs {
					// Found a connect pattern - move the IDs to the connectColumn
					doc[connectColumn] = ids
					// Remove the original nested object
					delete(doc, key)
					return
				}
			}
		}
	}
}

// transformFKConnect transforms FK connect patterns in the document.
// Converts owner: {connect: {id: 6}} -> owner_id: 6
func transformFKConnect(doc map[string]any, path, column string) {
	nested, ok := doc[path].(map[string]any)
	if !ok {
		return
	}
	connect, ok := nested["connect"].(map[string]any)
	if !ok {
		return
	}
	id, ok := connect["id"]
	if !ok {
		return
	}
	// Set the FK column to the connect ID
	doc[column] = id
	// Remove the original nested object
	delete(doc, path)
}

// substituteInMap recursively replaces parameter placeholders in a map.
func substituteInMap(m map[string]any, params map[string]any) map[string]any {
	result := make(map[string]any)
	for k, v := range m {
		result[k] = substituteValue(v, params)
	}
	return result
}

// substituteValue recursively replaces parameter placeholders in a value.
func substituteValue(v any, params map[string]any) any {
	switch val := v.(type) {
	case string:
		if replacement, ok := params[val]; ok {
			// If replacement is json.RawMessage ([]byte), parse it into Go types
			return parseJSONValue(replacement)
		}
		return val
	case map[string]any:
		return substituteInMap(val, params)
	case []any:
		result := make([]any, len(val))
		for i, item := range val {
			result[i] = substituteValue(item, params)
		}
		return result
	default:
		return v
	}
}

// parseJSONValue converts json.RawMessage or []byte into proper Go types.
// This is needed because json.RawMessage is just []byte, which MongoDB
// doesn't understand as JSON - it needs actual Go slices/maps.
func parseJSONValue(v any) any {
	switch val := v.(type) {
	case json.RawMessage:
		var parsed any
		if err := json.Unmarshal(val, &parsed); err != nil {
			return val // Return as-is if parsing fails
		}
		return parsed
	case []byte:
		var parsed any
		if err := json.Unmarshal(val, &parsed); err != nil {
			return val // Return as-is if parsing fails
		}
		return parsed
	default:
		return v
	}
}
