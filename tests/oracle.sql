-- Oracle initialization script

-- Create users table
CREATE TABLE users (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  full_name VARCHAR2(100) NOT NULL,
  phone VARCHAR2(255),
  avatar VARCHAR2(255),
  stripe_id VARCHAR2(255),
  email VARCHAR2(100) UNIQUE NOT NULL,
  category_counts CLOB CONSTRAINT chk_users_category_counts CHECK (category_counts IS JSON),
  disabled NUMBER(1) DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
  updated_at TIMESTAMP
);

-- Create categories table
CREATE TABLE categories (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR2(100) NOT NULL,
  description VARCHAR2(300),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
  updated_at TIMESTAMP
);

-- Create products table
CREATE TABLE products (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR2(100),
  description VARCHAR2(255),
  tags CLOB,
  metadata CLOB CONSTRAINT chk_products_metadata CHECK (metadata IS JSON),
  country_code VARCHAR2(3),
  price NUMBER(10, 2),
  count_likes NUMBER,
  owner_id NUMBER REFERENCES users(id),
  category_ids CLOB,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
  updated_at TIMESTAMP
);

-- Create purchases table
CREATE TABLE purchases (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  customer_id NUMBER REFERENCES users(id),
  product_id NUMBER REFERENCES products(id),
  quantity NUMBER,
  returned_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
  updated_at TIMESTAMP
);

-- Create notifications table
CREATE TABLE notifications (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  verb VARCHAR2(255),
  subject_type VARCHAR2(255),
  subject_id NUMBER,
  user_id NUMBER REFERENCES users(id),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
  updated_at TIMESTAMP
);

-- Create comments table
CREATE TABLE comments (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  body VARCHAR2(255),
  product_id NUMBER REFERENCES products(id),
  commenter_id NUMBER REFERENCES users(id),
  reply_to_id NUMBER,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
  updated_at TIMESTAMP
);

-- Create chats table
CREATE TABLE chats (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  body VARCHAR2(4000),
  reply_to_id NUMBER,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
  updated_at TIMESTAMP
);

-- Create graph tables
CREATE TABLE graph_node (
  id VARCHAR2(255) PRIMARY KEY,
  label VARCHAR2(255)
);

CREATE TABLE graph_edge (
  src_node VARCHAR2(255) REFERENCES graph_node(id),
  dst_node VARCHAR2(255) REFERENCES graph_node(id)
);

-- Create quotations table for JSON path testing
CREATE TABLE quotations (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  validity_period CLOB NOT NULL CONSTRAINT chk_quotations_validity_period CHECK (validity_period IS JSON),
  customer_id NUMBER REFERENCES users(id),
  amount NUMBER(10, 2),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

-- Insert 100 users using CONNECT BY LEVEL
INSERT INTO users (id, full_name, email, stripe_id, category_counts, disabled, created_at)
SELECT LEVEL,
  'User ' || LEVEL,
  'user' || LEVEL || '@test.com',
  'payment_id_' || (LEVEL + 1000),
  '[{"category_id": 1, "count": 400},{"category_id": 2, "count": 600}]',
  CASE WHEN LEVEL = 50 THEN 1 ELSE 0 END,
  TO_TIMESTAMP('2021-01-09 16:37:01', 'YYYY-MM-DD HH24:MI:SS')
FROM DUAL CONNECT BY LEVEL <= 100;

-- Insert 5 categories
INSERT INTO categories (id, name, description, created_at)
SELECT LEVEL,
  'Category ' || LEVEL,
  'Description for category ' || LEVEL,
  TO_TIMESTAMP('2021-01-09 16:37:01', 'YYYY-MM-DD HH24:MI:SS')
FROM DUAL CONNECT BY LEVEL <= 5;

-- Insert 100 products
INSERT INTO products (id, name, description, tags, metadata, country_code, category_ids, price, owner_id, created_at)
SELECT LEVEL,
  'Product ' || LEVEL,
  'Description for product ' || LEVEL,
  '["Tag 1", "Tag 2", "Tag 3", "Tag 4", "Tag 5"]',
  CASE WHEN MOD(LEVEL, 2) = 0 THEN '{"foo": true}' ELSE '{"bar": true}' END,
  'US',
  '[1,2,3,4,5]',
  (LEVEL + 10.5),
  LEVEL,
  TO_TIMESTAMP('2021-01-09 16:37:01', 'YYYY-MM-DD HH24:MI:SS')
FROM DUAL CONNECT BY LEVEL <= 100;

-- Insert 100 purchases
INSERT INTO purchases (id, customer_id, product_id, quantity, created_at)
SELECT LEVEL,
  CASE WHEN LEVEL >= 100 THEN 1 ELSE (LEVEL + 1) END,
  LEVEL,
  (LEVEL * 10),
  TO_TIMESTAMP('2021-01-09 16:37:01', 'YYYY-MM-DD HH24:MI:SS')
FROM DUAL CONNECT BY LEVEL <= 100;

-- Insert 100 notifications
INSERT INTO notifications (id, verb, subject_type, subject_id, user_id, created_at)
SELECT LEVEL,
  CASE WHEN MOD(LEVEL, 2) = 0 THEN 'Bought' ELSE 'Joined' END,
  CASE WHEN MOD(LEVEL, 2) = 0 THEN 'products' ELSE 'users' END,
  LEVEL,
  CASE WHEN LEVEL >= 2 THEN LEVEL - 1 ELSE NULL END,
  TO_TIMESTAMP('2021-01-09 16:37:01', 'YYYY-MM-DD HH24:MI:SS')
FROM DUAL CONNECT BY LEVEL <= 100;

-- Insert 100 comments (without reply_to_id first)
INSERT INTO comments (id, body, product_id, commenter_id, created_at)
SELECT LEVEL,
  'This is comment number ' || LEVEL,
  LEVEL,
  LEVEL,
  TO_TIMESTAMP('2021-01-09 16:37:01', 'YYYY-MM-DD HH24:MI:SS')
FROM DUAL CONNECT BY LEVEL <= 100;

-- Add self-referencing foreign key after comments exist
ALTER TABLE comments ADD CONSTRAINT fk_comments_reply FOREIGN KEY (reply_to_id) REFERENCES comments(id);

-- Update reply_to_id for comments (set reply_to_id = id - 1 for id >= 2)
UPDATE comments SET reply_to_id = id - 1 WHERE id >= 2;

-- Insert 5 chats
INSERT INTO chats (id, body, created_at)
SELECT LEVEL,
  'This is chat message number ' || LEVEL,
  TO_TIMESTAMP('2021-01-09 16:37:01', 'YYYY-MM-DD HH24:MI:SS')
FROM DUAL CONNECT BY LEVEL <= 5;

-- Add self-referencing foreign key for chats
ALTER TABLE chats ADD CONSTRAINT fk_chats_reply FOREIGN KEY (reply_to_id) REFERENCES chats(id);

-- Insert graph nodes
INSERT INTO graph_node (id, label) VALUES ('a', 'node a');

INSERT INTO graph_node (id, label) VALUES ('b', 'node b');

INSERT INTO graph_node (id, label) VALUES ('c', 'node c');

-- Insert graph edges
INSERT INTO graph_edge (src_node, dst_node) VALUES ('a', 'b');

INSERT INTO graph_edge (src_node, dst_node) VALUES ('a', 'c');

-- Insert quotations test data
INSERT INTO quotations (id, validity_period, customer_id, amount, created_at)
VALUES (1, '{"issue_date": "2024-09-15T03:03:16+0000", "expiry_date": "2024-10-15T03:03:16+0000", "status": "active"}', 1, 1000.00, TO_TIMESTAMP('2024-09-15 03:03:16', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO quotations (id, validity_period, customer_id, amount, created_at)
VALUES (2, '{"issue_date": "2024-09-20T03:03:16+0000", "expiry_date": "2024-10-20T03:03:16+0000", "status": "pending"}', 2, 2000.00, TO_TIMESTAMP('2024-09-20 03:03:16', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO quotations (id, validity_period, customer_id, amount, created_at)
VALUES (3, '{"issue_date": "2024-09-10T03:03:16+0000", "expiry_date": "2024-10-10T03:03:16+0000", "status": "expired"}', 3, 1500.00, TO_TIMESTAMP('2024-09-10 03:03:16', 'YYYY-MM-DD HH24:MI:SS'));

-- Create hot_products view (materialized view in Oracle)
CREATE VIEW hot_products AS
SELECT id as product_id, country_code FROM products WHERE id > 50;
/

-- Create scalar function is_hot_product
CREATE OR REPLACE FUNCTION is_hot_product(id NUMBER) RETURN NUMBER IS
  v_exists NUMBER;
BEGIN
  SELECT CASE WHEN EXISTS (
    SELECT 1 FROM hot_products hp WHERE hp.product_id = is_hot_product.id
  ) THEN 1 ELSE 0 END INTO v_exists FROM DUAL;
  RETURN v_exists;
END;
/

-- Create object types for table functions
CREATE OR REPLACE TYPE product_rec AS OBJECT (
  id NUMBER,
  name VARCHAR2(100)
);
/

CREATE OR REPLACE TYPE product_tab AS TABLE OF product_rec;
/

CREATE OR REPLACE TYPE user_rec AS OBJECT (
  tag_name VARCHAR2(100),
  id NUMBER,
  full_name VARCHAR2(100)
);
/

CREATE OR REPLACE TYPE user_tab AS TABLE OF user_rec;
/

-- Create table function get_oldest5_products
CREATE OR REPLACE FUNCTION get_oldest5_products RETURN product_tab PIPELINED IS
BEGIN
  FOR rec IN (SELECT id, name FROM products ORDER BY id ASC FETCH FIRST 5 ROWS ONLY) LOOP
    PIPE ROW(product_rec(rec.id, rec.name));
  END LOOP;
  RETURN;
END;
/

-- Create table function get_oldest_users
CREATE OR REPLACE FUNCTION get_oldest_users(user_count NUMBER, tag VARCHAR2) RETURN user_tab PIPELINED IS
BEGIN
  FOR rec IN (SELECT u.id, u.full_name FROM users u ORDER BY u.id ASC FETCH FIRST get_oldest_users.user_count ROWS ONLY) LOOP
    PIPE ROW(user_rec(get_oldest_users.tag, rec.id, rec.full_name));
  END LOOP;
  RETURN;
END;
/

-- Create table function get_product
CREATE OR REPLACE FUNCTION get_product(id NUMBER) RETURN product_tab PIPELINED IS
BEGIN
  FOR rec IN (SELECT p.id, p.name FROM products p ORDER BY p.id) LOOP
    PIPE ROW(product_rec(rec.id, rec.name));
  END LOOP;
  RETURN;
END;
/

-- GIS test table for spatial queries (Oracle Spatial)
-- Note: Requires gvenzl/oracle-free:23-full image (slim version excludes Spatial)
-- Oracle SDO_GEOMETRY uses (longitude, latitude) order
CREATE TABLE locations (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR2(100),
  geom SDO_GEOMETRY NOT NULL
);

-- Register geometry metadata (required for Oracle Spatial)
INSERT INTO USER_SDO_GEOM_METADATA (TABLE_NAME, COLUMN_NAME, DIMINFO, SRID)
VALUES (
  'LOCATIONS',
  'GEOM',
  SDO_DIM_ARRAY(
    SDO_DIM_ELEMENT('X', -180, 180, 0.005),
    SDO_DIM_ELEMENT('Y', -90, 90, 0.005)
  ),
  4326
);

-- Create spatial index
CREATE INDEX idx_locations_geom ON locations(geom) INDEXTYPE IS MDSYS.SPATIAL_INDEX;

-- Insert test locations using SDO_GEOMETRY(2001, SRID, SDO_POINT_TYPE(lon, lat, NULL), NULL, NULL)
INSERT INTO locations (id, name, geom) VALUES
  (1, 'San Francisco', SDO_GEOMETRY(2001, 4326, SDO_POINT_TYPE(-122.4194, 37.7749, NULL), NULL, NULL));
INSERT INTO locations (id, name, geom) VALUES
  (2, 'Oakland', SDO_GEOMETRY(2001, 4326, SDO_POINT_TYPE(-122.2711, 37.8044, NULL), NULL, NULL));
INSERT INTO locations (id, name, geom) VALUES
  (3, 'San Jose', SDO_GEOMETRY(2001, 4326, SDO_POINT_TYPE(-121.8853, 37.3382, NULL), NULL, NULL));
INSERT INTO locations (id, name, geom) VALUES
  (4, 'Berkeley', SDO_GEOMETRY(2001, 4326, SDO_POINT_TYPE(-122.2727, 37.8716, NULL), NULL, NULL));
INSERT INTO locations (id, name, geom) VALUES
  (5, 'Palo Alto', SDO_GEOMETRY(2001, 4326, SDO_POINT_TYPE(-122.1430, 37.4419, NULL), NULL, NULL));

-- Oracle Text index for full-text search on products
-- Note: Requires gvenzl/oracle-free:23-full image (slim version may not include Oracle Text)
CREATE INDEX idx_products_text ON products(name) INDEXTYPE IS CTXSYS.CONTEXT;

COMMIT
